### performance.now()

#### 実行結果
1回目：
console.log(costOfLength(10000));　→　0.000010199999809265137
console.log(costOfLength(100000000));　→　2.772999994456768e-8

2回目：
console.log(costOfLength(10000));　→　0.00001112000048160553
console.log(costOfLength(100000000));　→　6.114400006830693e-8

他：
console.log(costOfLength(500)); →　0.00028939999639987946
console.log(costOfLength(3000.0055));　→　0.0000017333321781419526
console.log(costOfLength(10)); →　0.001770000159740448
console.log(costOfLength(222222));　→　0.000005213705225077791

### 考えたこと
コードを見ると、costOfLoopは何もしない操作を繰り返す時間をperformanceで最初の時間と最後の時間の差として出している。costOfLengthPlusLoopはcostOfLoopに対して"Hello".lengthという文字列の長さをとる動作をN回繰り返す時間を同様に測っている。この各関数の時間差をNで割って一回当たりの"Hello".lengthの時間を測るコードであるが、実行するとNを増やすほど時間が小さくなる。
原因として考えられるのは、performance.now()はNodeのプロセスが実行されてからの経過時間を測っている、という特徴にあると思われる。返ってくる値がマイナスになったりすることも考慮すると、左辺であるcostOfLengthPlusLoopの結果がcostOfLoopに比べて非常に小さい値をとっている。なぜ…

### 調べた結果
・毎回同じ結果になる処理は、ループの外に移動されてしまい、ループ内で実行されているように見えて、実際には1回しか実行されていない。よって測定結果が正しくなくなる → costOfLoopのゆらぎ
・意図した処理が最適化されてしまい、何を測っているのかが曖昧になる → for文の前と後で測れていない？

#### メモ
・performance.now()はミリ秒単位のタイムスタンプを返す関数で、戻り値は小数部を持つ
・Date.now()とは異なり、Webページが読み込まれてからの経過時間、または、Nodeのプロセスが実行されてからの経過時間を表す
・Web ブラウザとNode で実装されている
・マイクロベンチマークとは、システムのパフォーマンスを評価する手法の一つ